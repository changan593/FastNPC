# 数据库外键约束修复报告

## 🐛 问题描述

用户注销时报错：
```
删除失败: update or delete on table "users" violates foreign key constraint "feedbacks_user_id_fkey" on table "feedbacks"
DETAIL: Key (id)=(2) is still referenced from table "feedbacks".
```

**根本原因**: 大部分表缺少 `ON DELETE CASCADE` 外键约束！

---

## 📊 当前状态分析

### ❌ 缺少外键约束的表

| 表名 | 缺少的外键约束 | 影响 |
|------|---------------|------|
| **characters** | `FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE` | 删除用户时角色不会自动删除 ❌ |
| **messages** | `FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE` | 删除用户时消息不会自动删除 ❌ |
| **messages** | `FOREIGN KEY (character_id) REFERENCES characters(id) ON DELETE CASCADE` | 删除角色时消息不会自动删除 ❌ |
| **user_settings** | `FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE` | 删除用户时设置不会自动删除 ❌ |
| **group_chats** | `FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE` | 删除用户时群聊不会自动删除 ❌ |
| **group_members** | `FOREIGN KEY (group_id) REFERENCES group_chats(id) ON DELETE CASCADE` | 删除群聊时成员不会自动删除 ❌ |
| **group_messages** | `FOREIGN KEY (group_id) REFERENCES group_chats(id) ON DELETE CASCADE` | 删除群聊时消息不会自动删除 ❌ |
| **feedbacks** | `FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE` | 删除用户时反馈不会自动删除 ❌ **（当前报错）** |

### ✅ 已正确配置的表

所有角色详细信息表都有正确的级联删除：
- ✅ `character_basic_info` → `ON DELETE CASCADE`
- ✅ `character_knowledge` → `ON DELETE CASCADE`
- ✅ `character_personality` → `ON DELETE CASCADE`
- ✅ `character_dialogue_rules` → `ON DELETE CASCADE`
- ✅ `character_tasks` → `ON DELETE CASCADE`
- ✅ `character_worldview` → `ON DELETE CASCADE`
- ✅ `character_background` → `ON DELETE CASCADE`
- ✅ `character_experiences` → `ON DELETE CASCADE`
- ✅ `character_relationships` → `ON DELETE CASCADE`
- ✅ `character_system_params` → `ON DELETE CASCADE`
- ✅ `character_source_info` → `ON DELETE CASCADE`
- ✅ `character_memories` → `ON DELETE CASCADE`

---

## 🎯 期望的级联删除行为

### 删除用户时应该自动删除：

```
users (用户)
  ↓ CASCADE
  ├─ characters (该用户的所有角色)
  │    ↓ CASCADE
  │    ├─ character_basic_info
  │    ├─ character_knowledge
  │    ├─ character_personality
  │    ├─ ... (所有角色详细信息表)
  │    └─ messages (该角色的所有消息) ✅ 已配置
  │
  ├─ messages (该用户的所有消息)
  ├─ user_settings (该用户的设置)
  ├─ group_chats (该用户创建的群聊)
  │    ↓ CASCADE
  │    ├─ group_members (群聊成员)
  │    └─ group_messages (群聊消息)
  │
  └─ feedbacks (该用户的反馈)
```

### 删除角色时应该自动删除：

```
characters (角色)
  ↓ CASCADE
  ├─ character_basic_info ✅
  ├─ character_knowledge ✅
  ├─ character_personality ✅
  ├─ ... (所有详细信息表) ✅
  └─ messages (该角色的消息) ❌ 需要修复
```

### 删除群聊时应该自动删除：

```
group_chats (群聊)
  ↓ CASCADE
  ├─ group_members (成员) ❌ 需要修复
  └─ group_messages (消息) ❌ 需要修复
```

---

## 🔧 修复方案

### 方案A：ALTER TABLE 添加约束（生产环境推荐）

**优点**：
- 不需要删除数据
- 不需要重建表
- 对现有数据无影响

**缺点**：
- 如果已有"孤儿数据"（引用不存在的ID），会失败
- 需要先清理孤儿数据

### 方案B：重新创建表（开发环境推荐）

**优点**：
- 完全干净的schema
- 确保没有问题

**缺点**：
- 需要删除并重建所有表
- **会丢失所有数据** ⚠️

---

## 🚀 实施步骤（方案A - 生产环境）

### 步骤1：检查孤儿数据

```sql
-- 检查characters表是否有孤儿记录
SELECT c.id, c.user_id, c.name 
FROM characters c 
LEFT JOIN users u ON c.user_id = u.id 
WHERE u.id IS NULL;

-- 检查messages表是否有孤儿记录
SELECT m.id, m.user_id, m.character_id 
FROM messages m 
LEFT JOIN users u ON m.user_id = u.id 
WHERE u.id IS NULL;

-- 检查feedbacks表是否有孤儿记录
SELECT f.id, f.user_id, f.title 
FROM feedbacks f 
LEFT JOIN users u ON f.user_id = u.id 
WHERE u.id IS NULL;
```

### 步骤2：清理孤儿数据（如果有）

```sql
-- 删除孤儿角色
DELETE FROM characters WHERE user_id NOT IN (SELECT id FROM users);

-- 删除孤儿消息
DELETE FROM messages WHERE user_id NOT IN (SELECT id FROM users);
DELETE FROM messages WHERE character_id NOT IN (SELECT id FROM characters);

-- 删除孤儿反馈
DELETE FROM feedbacks WHERE user_id NOT IN (SELECT id FROM users);

-- 删除孤儿群聊
DELETE FROM group_chats WHERE user_id NOT IN (SELECT id FROM users);
DELETE FROM group_members WHERE group_id NOT IN (SELECT id FROM group_chats);
DELETE FROM group_messages WHERE group_id NOT IN (SELECT id FROM group_chats);
```

### 步骤3：添加外键约束（PostgreSQL）

```sql
-- 1. characters表
ALTER TABLE characters 
ADD CONSTRAINT characters_user_id_fkey 
FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE;

-- 2. messages表
ALTER TABLE messages 
ADD CONSTRAINT messages_user_id_fkey 
FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE;

ALTER TABLE messages 
ADD CONSTRAINT messages_character_id_fkey 
FOREIGN KEY (character_id) REFERENCES characters(id) ON DELETE CASCADE;

-- 3. user_settings表
ALTER TABLE user_settings 
ADD CONSTRAINT user_settings_user_id_fkey 
FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE;

-- 4. group_chats表
ALTER TABLE group_chats 
ADD CONSTRAINT group_chats_user_id_fkey 
FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE;

-- 5. group_members表
ALTER TABLE group_members 
ADD CONSTRAINT group_members_group_id_fkey 
FOREIGN KEY (group_id) REFERENCES group_chats(id) ON DELETE CASCADE;

-- 6. group_messages表
ALTER TABLE group_messages 
ADD CONSTRAINT group_messages_group_id_fkey 
FOREIGN KEY (group_id) REFERENCES group_chats(id) ON DELETE CASCADE;

-- 7. feedbacks表 (修复当前报错)
ALTER TABLE feedbacks 
ADD CONSTRAINT feedbacks_user_id_fkey 
FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE;
```

### 步骤4：更新 db_init.py（防止新数据库有同样问题）

需要修改 `fastnpc/api/auth/db_init.py`，在所有建表语句中添加外键约束。

---

## 📋 修复脚本

### 创建修复脚本：fix_foreign_keys.sql

**PostgreSQL版本**：
```sql
-- FastNPC 数据库外键约束修复脚本
-- 执行前请备份数据库！

BEGIN;

-- 检查并清理孤儿数据
DO $$ 
BEGIN
    RAISE NOTICE '开始清理孤儿数据...';
    
    -- 清理孤儿角色
    DELETE FROM characters WHERE user_id NOT IN (SELECT id FROM users);
    RAISE NOTICE '清理了 % 个孤儿角色', (SELECT count(*) FROM characters WHERE user_id NOT IN (SELECT id FROM users));
    
    -- 清理孤儿消息
    DELETE FROM messages WHERE user_id NOT IN (SELECT id FROM users);
    DELETE FROM messages WHERE character_id NOT IN (SELECT id FROM characters);
    
    -- 清理孤儿设置
    DELETE FROM user_settings WHERE user_id NOT IN (SELECT id FROM users);
    
    -- 清理孤儿群聊
    DELETE FROM group_chats WHERE user_id NOT IN (SELECT id FROM users);
    DELETE FROM group_members WHERE group_id NOT IN (SELECT id FROM group_chats);
    DELETE FROM group_messages WHERE group_id NOT IN (SELECT id FROM group_chats);
    
    -- 清理孤儿反馈
    DELETE FROM feedbacks WHERE user_id NOT IN (SELECT id FROM users);
    
    RAISE NOTICE '孤儿数据清理完成';
END $$;

-- 添加外键约束
RAISE NOTICE '开始添加外键约束...';

-- characters表
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_constraint WHERE conname = 'characters_user_id_fkey'
    ) THEN
        ALTER TABLE characters 
        ADD CONSTRAINT characters_user_id_fkey 
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE;
        RAISE NOTICE '✓ characters.user_id 外键约束已添加';
    END IF;
END $$;

-- messages表
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_constraint WHERE conname = 'messages_user_id_fkey'
    ) THEN
        ALTER TABLE messages 
        ADD CONSTRAINT messages_user_id_fkey 
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE;
        RAISE NOTICE '✓ messages.user_id 外键约束已添加';
    END IF;
    
    IF NOT EXISTS (
        SELECT 1 FROM pg_constraint WHERE conname = 'messages_character_id_fkey'
    ) THEN
        ALTER TABLE messages 
        ADD CONSTRAINT messages_character_id_fkey 
        FOREIGN KEY (character_id) REFERENCES characters(id) ON DELETE CASCADE;
        RAISE NOTICE '✓ messages.character_id 外键约束已添加';
    END IF;
END $$;

-- user_settings表
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_constraint WHERE conname = 'user_settings_user_id_fkey'
    ) THEN
        ALTER TABLE user_settings 
        ADD CONSTRAINT user_settings_user_id_fkey 
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE;
        RAISE NOTICE '✓ user_settings.user_id 外键约束已添加';
    END IF;
END $$;

-- group_chats表
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_constraint WHERE conname = 'group_chats_user_id_fkey'
    ) THEN
        ALTER TABLE group_chats 
        ADD CONSTRAINT group_chats_user_id_fkey 
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE;
        RAISE NOTICE '✓ group_chats.user_id 外键约束已添加';
    END IF;
END $$;

-- group_members表
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_constraint WHERE conname = 'group_members_group_id_fkey'
    ) THEN
        ALTER TABLE group_members 
        ADD CONSTRAINT group_members_group_id_fkey 
        FOREIGN KEY (group_id) REFERENCES group_chats(id) ON DELETE CASCADE;
        RAISE NOTICE '✓ group_members.group_id 外键约束已添加';
    END IF;
END $$;

-- group_messages表
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_constraint WHERE conname = 'group_messages_group_id_fkey'
    ) THEN
        ALTER TABLE group_messages 
        ADD CONSTRAINT group_messages_group_id_fkey 
        FOREIGN KEY (group_id) REFERENCES group_chats(id) ON DELETE CASCADE;
        RAISE NOTICE '✓ group_messages.group_id 外键约束已添加';
    END IF;
END $$;

-- feedbacks表 (修复当前报错)
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_constraint WHERE conname = 'feedbacks_user_id_fkey'
    ) THEN
        -- 先删除旧的约束（如果存在但没有CASCADE）
        ALTER TABLE feedbacks DROP CONSTRAINT IF EXISTS feedbacks_user_id_fkey;
        
        -- 添加新的约束（带CASCADE）
        ALTER TABLE feedbacks 
        ADD CONSTRAINT feedbacks_user_id_fkey 
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE;
        RAISE NOTICE '✓ feedbacks.user_id 外键约束已添加（ON DELETE CASCADE）';
    END IF;
END $$;

COMMIT;

-- 验证外键约束
SELECT 
    tc.table_name, 
    kcu.column_name, 
    ccu.table_name AS foreign_table_name,
    ccu.column_name AS foreign_column_name,
    rc.delete_rule
FROM information_schema.table_constraints AS tc 
JOIN information_schema.key_column_usage AS kcu
    ON tc.constraint_name = kcu.constraint_name
    AND tc.table_schema = kcu.table_schema
JOIN information_schema.constraint_column_usage AS ccu
    ON ccu.constraint_name = tc.constraint_name
    AND ccu.table_schema = tc.table_schema
JOIN information_schema.referential_constraints AS rc
    ON rc.constraint_name = tc.constraint_name
WHERE tc.constraint_type = 'FOREIGN KEY'
AND tc.table_name IN ('characters', 'messages', 'user_settings', 'group_chats', 'group_members', 'group_messages', 'feedbacks')
ORDER BY tc.table_name, kcu.column_name;
```

---

## 🧪 测试验证

### 测试1：删除用户

```python
# 创建测试用户
test_user_id = create_user("test_delete", "password")

# 创建测试数据
create_character(test_user_id, "测试角色")
add_message(test_user_id, char_id, "user", "测试消息")
create_group_chat(test_user_id, "测试群聊")
create_feedback(test_user_id, "测试反馈", "内容")

# 删除用户（应该级联删除所有相关数据）
delete_account(test_user_id)

# 验证：所有相关数据应该被删除
assert get_characters(test_user_id) == []
assert get_messages(test_user_id, char_id) == []
assert get_group_chats(test_user_id) == []
assert get_feedbacks_by_user(test_user_id) == []
```

### 测试2：删除角色

```python
# 创建测试角色和消息
char_id = create_character(user_id, "测试角色")
add_message(user_id, char_id, "user", "测试消息1")
add_message(user_id, char_id, "assistant", "测试回复1")

# 删除角色（应该级联删除所有消息和详细信息）
delete_character(user_id, "测试角色")

# 验证：角色和所有相关数据应该被删除
assert get_messages(user_id, char_id) == []
assert load_character_full_data(char_id) == None
```

### 测试3：删除群聊

```python
# 创建测试群聊
group_id = create_group_chat(user_id, "测试群聊")
add_group_member(group_id, "character", char_id, "角色1")
add_group_message(group_id, "user", user_id, "用户", "测试消息")

# 删除群聊（应该级联删除所有成员和消息）
delete_group_chat(user_id, group_id)

# 验证：群聊和所有相关数据应该被删除
assert get_group_members(group_id) == []
assert get_group_messages(group_id) == []
```

---

## ⚠️ 注意事项

### 1. 备份数据库

**执行修复前务必备份！**

```bash
# PostgreSQL备份
pg_dump -U fastnpc -d fastnpc > backup_$(date +%Y%m%d_%H%M%S).sql

# 恢复（如果需要）
psql -U fastnpc -d fastnpc < backup_YYYYMMDD_HHMMSS.sql
```

### 2. 孤儿数据

如果数据库中已经存在"孤儿数据"（引用不存在的用户/角色），添加外键约束会失败。必须先清理。

### 3. 性能影响

添加外键约束时：
- 小数据库（<1万条记录）：几秒钟
- 大数据库：可能需要几分钟，期间表会被锁定

### 4. SQLite特殊处理

SQLite不支持 `ALTER TABLE ADD CONSTRAINT`，需要：
1. 创建新表（带外键约束）
2. 复制数据
3. 删除旧表
4. 重命名新表

---

## 📊 影响评估

### 修复后的改进

✅ **数据一致性**：
- 不会有孤儿记录
- 删除操作自动级联
- 数据库完整性得到保障

✅ **代码简化**：
- 删除用户时不需要手动删除相关表
- 删除角色时不需要手动删除消息
- 减少代码bug风险

✅ **性能提升**：
- 数据库自动处理级联删除（比手动逐表删除快）
- 减少应用层代码执行时间

### 当前 delete_account() 代码问题

```python
# fastnpc/api/auth/users.py
def delete_account(user_id: int) -> None:
    conn = _get_conn()
    try:
        cur = conn.cursor()
        # 删除该用户的所有消息
        cur.execute("SELECT id FROM characters WHERE user_id=%s", (user_id,))
        char_ids = [int(r[0]) for r in cur.fetchall()]
        if char_ids:
            for cid in char_ids:
                cur.execute("DELETE FROM messages WHERE user_id=%s AND character_id=%s", (user_id, cid))
        # 删除角色
        cur.execute("DELETE FROM characters WHERE user_id=%s", (user_id,))
        # 删除用户设置
        cur.execute("DELETE FROM user_settings WHERE user_id=%s", (user_id,))
        # 删除用户
        cur.execute("DELETE FROM users WHERE id=%s", (user_id,))
        conn.commit()
    finally:
        _return_conn(conn)
```

**问题**：
- ❌ 没有删除 feedbacks（导致当前报错）
- ❌ 没有删除 group_chats, group_members, group_messages
- ❌ 手动逐表删除（效率低，容易遗漏）

**修复后只需**：
```python
def delete_account(user_id: int) -> None:
    conn = _get_conn()
    try:
        cur = conn.cursor()
        # 一条SQL搞定，数据库自动级联删除所有相关数据！
        cur.execute("DELETE FROM users WHERE id=%s", (user_id,))
        conn.commit()
    finally:
        _return_conn(conn)
```

---

## 🎯 总结

### 当前问题

- ❌ 8个表缺少外键约束
- ❌ 删除用户/角色/群聊时报错或留下孤儿数据
- ❌ 需要手动管理级联删除（容易出错）

### 修复后

- ✅ 所有表都有正确的外键约束
- ✅ 删除操作自动级联，不会出错
- ✅ 代码更简洁，维护更容易
- ✅ 数据一致性得到保障

### 下一步

1. ✅ 备份数据库
2. ✅ 执行修复脚本（fix_foreign_keys.sql）
3. ✅ 更新 db_init.py（防止新数据库有同样问题）
4. ✅ 简化 delete_account() 代码
5. ✅ 测试验证

---

*报告生成时间：2025-10-18*  
*问题严重程度：高 ⚠️*  
*修复优先级：紧急 🔥*

