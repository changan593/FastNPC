# 缓存机制优化计划

## 目标

实施缓存层，减少数据库查询：
- **数据库查询减少**：80%
- **响应速度提升**：50-200ms → 1-5ms
- **数据库负载降低**：80%
- **系统吞吐量提升**：2-3倍

---

## 当前问题分析

### 问题1：频繁查询用户设置

```python
# 每次聊天都查询（fastnpc/api/routes/chat_routes.py）
def api_post_message(...):
    user_settings = get_user_settings(user_id)  # 查数据库 ❌
    ctx_max_chat = int(user_settings.get('ctx_max_chat') or 3000)
    # ...
```

**影响**：
- 每条消息查询1次：50-100ms
- 10人并发：10次查询
- 用户设置很少变化，但每次都查

### 问题2：频繁查询角色配置

```python
# 每次聊天都查询角色完整数据
def _load_character_profile(role, user_id):
    character_id = get_character_id(user_id, role)  # 查数据库 ❌
    full_data = load_character_full_data(character_id)  # 查数据库 ❌
    memories = load_character_memories(character_id)  # 查数据库 ❌
    # 总共3次数据库查询！
```

**影响**：
- 每条消息查询3次：150-300ms
- 角色配置很少变化，但每次都查

### 问题3：频繁查询角色列表

```python
# 前端每次刷新都查询
@router.get("/api/characters")
def api_characters(request):
    return list_characters(user_id)  # 查数据库 ❌
```

**影响**：
- 用户切换页面就查询
- 列表很少变化（只有创建/删除时）

### 统计

**单次聊天数据库查询**：
```
1. 用户设置：1次
2. 角色ID：1次
3. 角色配置：8次（8个分类表）
4. 角色记忆：1次
总计：11次查询 ❌

优化后：0次查询（全部缓存）✅
```

---

## 解决方案

### 方案：Python内存缓存（functools.lru_cache + 手动缓存）

**技术选型**：

#### 选项1：functools.lru_cache（推荐开始使用）
- ✅ Python内置，无需额外依赖
- ✅ 简单易用，装饰器即可
- ✅ 自动LRU淘汰策略
- ⚠️ 单进程内存缓存（多worker不共享）

#### 选项2：Redis（可选，后续优化）
- ✅ 多worker共享
- ✅ 持久化
- ✅ 功能强大
- ⚠️ 需要额外部署Redis

#### 选项3：自定义内存缓存字典
- ✅ 完全可控
- ✅ 可添加TTL、失效策略
- ⚠️ 需要手动管理

**推荐方案**：
1. **阶段1**：使用 `lru_cache` + 自定义缓存字典（简单快速）
2. **阶段2**（可选）：迁移到Redis（如果需要多worker共享）

---

## 实施步骤

### 步骤1：创建缓存管理模块

**新建文件**：`fastnpc/api/cache.py`

**功能**：
- 统一缓存管理
- TTL支持（过期时间）
- 缓存失效机制
- 缓存统计

**核心类**：
```python
class SimpleCache:
    """简单的内存缓存，支持TTL"""
    def __init__(self, default_ttl=300):
        self._cache = {}
        self._timestamps = {}
        self._default_ttl = default_ttl
        self._lock = threading.Lock()
    
    def get(self, key):
        """获取缓存"""
        pass
    
    def set(self, key, value, ttl=None):
        """设置缓存"""
        pass
    
    def delete(self, key):
        """删除缓存"""
        pass
    
    def clear(self):
        """清空缓存"""
        pass
```

### 步骤2：缓存用户设置

**更新文件**：`fastnpc/api/auth/users.py`

**改动**：
```python
# 添加LRU缓存
from functools import lru_cache

@lru_cache(maxsize=1000)  # 缓存1000个用户
def get_user_settings_cached(user_id: int) -> Dict[str, Any]:
    """缓存版本的用户设置查询"""
    return get_user_settings(user_id)

# 提供缓存清理函数
def invalidate_user_settings_cache(user_id: int):
    """清除指定用户的设置缓存"""
    get_user_settings_cached.cache_clear()
```

**使用位置**：
- `chat_routes.py`
- `group_routes.py`

### 步骤3：缓存角色配置

**更新文件**：`fastnpc/api/utils.py`

**改动**：
```python
from fastnpc.api.cache import SimpleCache

# 角色配置缓存（5分钟TTL）
character_cache = SimpleCache(default_ttl=300)

def _load_character_profile_cached(role: str, user_id: int):
    """缓存版本的角色配置加载"""
    cache_key = f"char_profile:{user_id}:{role}"
    
    # 尝试从缓存获取
    cached = character_cache.get(cache_key)
    if cached is not None:
        return cached
    
    # 缓存未命中，查询数据库
    profile = _load_character_profile(role, user_id)
    
    # 保存到缓存
    if profile:
        character_cache.set(cache_key, profile)
    
    return profile

def invalidate_character_cache(user_id: int, role: str):
    """清除角色缓存（更新时调用）"""
    cache_key = f"char_profile:{user_id}:{role}"
    character_cache.delete(cache_key)
```

### 步骤4：缓存角色ID映射

**更新文件**：`fastnpc/api/auth/characters.py`

**改动**：
```python
from functools import lru_cache

@lru_cache(maxsize=5000)  # 缓存5000个映射
def get_character_id_cached(user_id: int, name: str) -> Optional[int]:
    """缓存版本的角色ID查询"""
    return get_character_id(user_id, name)

def invalidate_character_id_cache():
    """清除角色ID缓存"""
    get_character_id_cached.cache_clear()
```

### 步骤5：缓存角色列表

**更新文件**：`fastnpc/api/utils.py`

**改动**：
```python
# 角色列表缓存（1分钟TTL）
character_list_cache = SimpleCache(default_ttl=60)

def _list_structured_files_cached(user_id: int):
    """缓存版本的角色列表"""
    cache_key = f"char_list:{user_id}"
    
    cached = character_list_cache.get(cache_key)
    if cached is not None:
        return cached
    
    items = _list_structured_files(user_id)
    character_list_cache.set(cache_key, items)
    
    return items

def invalidate_character_list_cache(user_id: int):
    """清除角色列表缓存"""
    cache_key = f"char_list:{user_id}"
    character_list_cache.delete(cache_key)
```

### 步骤6：更新调用点

**更新文件**：
- `fastnpc/api/routes/chat_routes.py`
- `fastnpc/api/routes/group_routes.py`
- `fastnpc/api/routes/character_routes.py`

**改动**：将所有数据库查询替换为缓存版本

### 步骤7：缓存失效机制

**关键点**：在数据更新时清除缓存

```python
# 用户设置更新时
def update_user_settings(...):
    # 更新数据库
    ...
    # 清除缓存
    invalidate_user_settings_cache(user_id)

# 角色更新时
def update_character_structured(...):
    # 更新数据库
    ...
    # 清除缓存
    invalidate_character_cache(user_id, role)
    invalidate_character_list_cache(user_id)

# 角色删除时
def delete_character(...):
    # 删除数据库记录
    ...
    # 清除缓存
    invalidate_character_cache(user_id, name)
    invalidate_character_list_cache(user_id)
```

### 步骤8：缓存监控和统计

**功能**：
- 缓存命中率统计
- 缓存大小监控
- 性能对比

```python
class CacheStats:
    def __init__(self):
        self.hits = 0
        self.misses = 0
    
    @property
    def hit_rate(self):
        total = self.hits + self.misses
        return self.hits / total if total > 0 else 0
    
    def record_hit(self):
        self.hits += 1
    
    def record_miss(self):
        self.misses += 1
```

---

## 缓存策略

### 1. 用户设置缓存

```python
# 策略
缓存键：f"user_settings:{user_id}"
TTL：永久（LRU淘汰）
失效时机：用户更新设置时
缓存大小：1000个用户

# 原因
- 用户设置几乎不变
- 每次聊天都需要
- 数据量小（几KB）
```

### 2. 角色配置缓存

```python
# 策略
缓存键：f"char_profile:{user_id}:{role}"
TTL：5分钟
失效时机：角色更新时
缓存大小：无限制（自动淘汰）

# 原因
- 角色配置变化少
- 数据量较大（几十KB）
- 每次聊天都需要
```

### 3. 角色ID映射缓存

```python
# 策略
缓存键：(user_id, name)
TTL：永久（LRU淘汰）
失效时机：角色创建/删除时
缓存大小：5000个映射

# 原因
- ID映射不变
- 查询频繁
- 数据量极小
```

### 4. 角色列表缓存

```python
# 策略
缓存键：f"char_list:{user_id}"
TTL：1分钟
失效时机：角色创建/删除时
缓存大小：无限制

# 原因
- 列表变化较少
- 前端频繁刷新
- 数据量中等
```

---

## 性能提升预期

### 单次聊天对话

| 指标 | 优化前 | 优化后 | 提升 |
|------|--------|--------|------|
| **数据库查询次数** | 11次 | 0次 | **减少100%** 🎉 |
| **数据库查询耗时** | 300-500ms | 0ms | **节省500ms** ⚡ |
| **总响应时间** | 5-10秒 | 4.5-9.5秒 | **快10%** |

### 角色列表查询

| 指标 | 优化前 | 优化后 | 提升 |
|------|--------|--------|------|
| **响应时间** | 50-200ms | 1-5ms | **10-40倍** 🚀 |
| **数据库负载** | 每次查询 | 1分钟1次 | **减少99%** |

### 100次聊天对话

```
优化前：
- 数据库查询：1100次
- 数据库耗时：30-50秒
- 总耗时：500-1000秒

优化后：
- 数据库查询：0-10次（首次+过期）
- 数据库耗时：0-3秒
- 总耗时：450-950秒

节省：10%响应时间 + 95%数据库负载
```

### 数据库负载降低

```
场景：50人同时在线

优化前：
- 每人每分钟：10条消息
- 每条消息：11次查询
- 总查询：50×10×11 = 5500次/分钟

优化后：
- 首次查询：50×11 = 550次
- 后续查询：0次（缓存命中）
- 总查询：550次/首次，后续0-50次/分钟

降低：90-98%数据库负载 🎊
```

---

## 缓存一致性

### 问题：多Worker缓存不一致

**场景**：
```
Worker1: 更新角色配置 → 清除Worker1缓存 ✓
Worker2: 仍有旧缓存 ✗
```

**解决方案**：

#### 方案A：接受短期不一致（推荐，2核服务器）
```python
# 使用TTL自动过期
- 角色配置：5分钟TTL
- 用户设置：更新时全局清除
- 角色列表：1分钟TTL

优点：
- 简单，无需额外组件
- 对用户影响小（5分钟内生效）
- 适合2 worker场景

缺点：
- 短期不一致（最多5分钟）
```

#### 方案B：使用Redis共享缓存（可选）
```python
# 所有worker共享Redis
- 立即一致
- 需要部署Redis
- 适合多worker场景（8+）

何时迁移：
- Worker数量 >4
- 需要立即一致性
- 有运维资源
```

#### 方案C：缓存失效广播（复杂）
```python
# Worker间通信
- 使用消息队列
- 复杂度高
- 不推荐（2核服务器）
```

**推荐**：先用方案A（TTL），如果有问题再升级到Redis

---

## 内存使用评估

### 2核2G服务器（2 workers）

```python
单个缓存项大小估算：

用户设置：~1KB × 1000 = 1MB
角色配置：~50KB × 100 = 5MB
角色ID映射：~100B × 5000 = 500KB
角色列表：~10KB × 50 = 500KB

总计（单worker）：~7MB
2 workers：~14MB

服务器总内存：2G
可用内存：~1.5G
缓存占用：14MB（1%）

结论：内存占用可忽略 ✓
```

---

## 注意事项

### 1. 缓存失效

**关键**：数据更新时必须清除缓存

```python
# ✅ 正确
def update_user_settings(...):
    # 1. 更新数据库
    conn = _get_conn()
    cur.execute("UPDATE user_settings ...")
    conn.commit()
    
    # 2. 清除缓存
    invalidate_user_settings_cache(user_id)

# ❌ 错误
def update_user_settings(...):
    # 只更新数据库，忘记清除缓存
    cur.execute("UPDATE user_settings ...")
    conn.commit()
    # 缓存仍是旧数据！
```

### 2. 并发安全

```python
# ✅ 使用锁保护
class SimpleCache:
    def __init__(self):
        self._lock = threading.Lock()
    
    def get(self, key):
        with self._lock:
            return self._cache.get(key)
```

### 3. 内存泄漏

```python
# ✅ 使用LRU自动淘汰
@lru_cache(maxsize=1000)  # 限制大小
def get_user_settings_cached(...):
    pass

# ✅ 使用TTL自动过期
cache = SimpleCache(default_ttl=300)  # 5分钟过期
```

### 4. 缓存预热

```python
# 可选：应用启动时预加载热点数据
def warmup_cache():
    """预热缓存"""
    # 加载活跃用户设置
    for user_id in get_active_users():
        get_user_settings_cached(user_id)
```

---

## 监控和调试

### 缓存命中率

```python
# 添加统计
@router.get("/admin/cache/stats")
def cache_stats(request: Request):
    return {
        "user_settings": {
            "hits": ...,
            "misses": ...,
            "hit_rate": "95%"
        },
        "character_profile": {
            "hits": ...,
            "misses": ...,
            "hit_rate": "90%"
        }
    }
```

### 缓存大小

```python
# 监控内存使用
def get_cache_size():
    import sys
    return {
        "user_settings_size": sys.getsizeof(user_settings_cache),
        "character_cache_size": sys.getsizeof(character_cache),
    }
```

### 清除所有缓存

```python
# 调试用
@router.post("/admin/cache/clear")
def clear_all_caches(request: Request):
    get_user_settings_cached.cache_clear()
    character_cache.clear()
    character_list_cache.clear()
    return {"ok": True}
```

---

## 实施优先级

### 高优先级（必须）

1. ✅ 用户设置缓存（减少50%查询）
2. ✅ 角色ID映射缓存（减少10%查询）

### 中优先级（推荐）

3. ✅ 角色配置缓存（减少20%查询）
4. ✅ 角色列表缓存（减少10%查询）

### 低优先级（可选）

5. ⏸️ Redis共享缓存（多worker一致性）
6. ⏸️ 缓存预热（启动速度优化）

---

## 验收标准

- ✅ 数据库查询减少80%
- ✅ 响应时间减少50-200ms
- ✅ 缓存命中率>90%
- ✅ 内存使用<50MB
- ✅ 更新数据时缓存正确失效
- ✅ 无缓存一致性问题

---

## 后续优化（可选）

### 1. 迁移到Redis

**何时**：
- Worker数量>4
- 需要持久化
- 需要立即一致性

**改动**：
```python
import redis
r = redis.Redis(host='localhost', port=6379)

def get_user_settings_cached(user_id):
    key = f"user_settings:{user_id}"
    cached = r.get(key)
    if cached:
        return json.loads(cached)
    
    settings = get_user_settings(user_id)
    r.setex(key, 300, json.dumps(settings))
    return settings
```

### 2. 分布式缓存

**使用场景**：
- 多服务器部署
- 需要共享缓存

**技术**：
- Redis Cluster
- Memcached

### 3. 缓存层次

```
L1: 进程内缓存（lru_cache）- 最快
L2: Redis缓存 - 较快，共享
L3: 数据库 - 较慢，持久化
```

---

## 总结

这个优化将带来：

✅ **80%数据库查询减少**  
✅ **2-3倍系统吞吐量提升**  
✅ **90%数据库负载降低**  
✅ **10%响应时间提升**  

**综合效果（所有优化）**：
1. 数据库连接池：3-5倍
2. LLM异步调用：10倍
3. 多Worker：2倍
4. 缓存机制：2-3倍（吞吐量）
5. **总计：120-300倍性能提升** 🎉

---

*计划创建时间*: 2025-10-17  
*优化类型*: 缓存机制  
*预期提升*: 80%查询减少 + 2-3倍吞吐量

